<!doctype html>
<html lang="en_US">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"> 
    <title>CSC 407: Computer Systems II: 2023 Winter, Assignment #1 Solution</title>
    <style>
      H2 { text-align: center }
      H3 { text-align: center }
    </style>
  </head>

  <body>
    <h2>CSC 407: Computer Systems II: 2023 Winter<br/>Assignment #1 Solution</h2>
    <h3>Last Modified 2023 February 2</h3>

    <h4>Purpose:</h4>
    To go over:
    <ul>
      <li>Compiler optimizations</li>
      <li>Program profiling (timing)</li>
      <li>Header files</li>
      <li>Linking and object file layout</li>
    </ul>

    <h4>Computing</h4>
    <p>
      Please <a href="http://www.putty.org/">ssh</a> into one of the following:
      <ul>
	<li>cdmlsrvprd01.dpu.depaul.edu</li>
      </ul>
      or use your own Linux machine.
    </p>

    <p>
      Please submit a .zip file
      (<em>not</em> .7z or any other non-standard compression!)
      file of all source code (.h and .c files) <em>and</em>
      a .txt/.pdf/.doc/.odt file containing your answer to the questions.
    </p>

    <ol type="1">
      <li>
	<h4>Please copy-and-paste the following files (0 Points):</h4>
	<h5>insertionSort.c</h5>
	<p>
	  <pre>
/*-------------------------------------------------------------------------*
 *---									---*
 *---		insertionSort.c						---*
 *---									---*
 *---	    This file defines a function that implements the insertion-	---*
 *---	sort algorithm.							---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a					Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	&quot;header.h&quot;

//  PURPOSE:  To sort the &apos;arrayLen&apos; strings in array &apos;array&apos; with the
//	insertion-sort algorithm.  No return value.
void		insertionSort	(char**		array,
				 int		arrayLen
				)
{
  int	i;
  int	j;

  for  (i = 0;  i &lt; arrayLen-1;  i++)
    for  (j = i+1;  j &lt; arrayLen;  j++)
      if  ( strncmp(array[i],array[j],strLen) &gt; 0 )
	swap(array,i,j);
}
	  </pre>
	</p>

	<h5>quickSort.c</h5>
	<p>
	  <pre>
/*-------------------------------------------------------------------------*
 *---									---*
 *---		quickSort.c						---*
 *---									---*
 *---	    This file defines a function that implements the quick-sort	---*
 *---	algorithm.							---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1b					Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	&quot;header.h&quot;


int		partition	(char**		array,
				 char*		pivot,
				 int		lo,
				 int		hi
				)
{
  lo--;
  hi++;

  while  (1)
  {
    do
    {
      lo++;
    }
    while  (strncmp(array[lo],pivot,strLen) &lt; 0);

    do
    {
      hi--;
    }
    while  (strncmp(array[hi],pivot,strLen) &gt; 0);

    if  (lo &gt;= hi)
      break;

    swap(array,lo,hi);
  }

  return(hi);
}


int		pivot		(char**		array,
				 int		lo,
				 int		hi
				)
{
  char*	atLo	= array[lo];
  char*	atMid	= array[(lo+hi)/2];
  char*	atHi	= array[hi];

  if  ( ((strncmp(atLo,atMid,strLen)&lt;=0) &amp;&amp; (strncmp(atMid,atHi,strLen)&lt;=0))  ||
        ((strncmp(atLo,atMid,strLen)&gt;=0) &amp;&amp; (strncmp(atMid,atHi,strLen)&gt;=0))
      )
    return((lo+hi)/2);

  if  ( ((strncmp(atMid,atLo,strLen)&lt;=0) &amp;&amp; (strncmp(atLo,atHi,strLen)&lt;=0))  ||
	((strncmp(atMid,atLo,strLen)&gt;=0) &amp;&amp; (strncmp(atLo,atHi,strLen)&gt;=0))
	)
    return(lo);

  return(hi);
}


void		quickSort_	(char**		array,
				 int		lo,
				 int		hi
				)
{
  if  (lo &lt; hi)
  {
    int	left;
    int	right;
    int	p	= pivot(array,lo,hi);

    p		= partition(array,array[p],lo,hi);
    quickSort_(array,lo,p);
    quickSort_(array,p+1,hi);
  }
}


//  PURPOSE:  To sort the &apos;arrayLen&apos; strings in array &apos;array&apos; with the
//	quick-sort algorithm.  No return value.
void		quickSort	(char**		array,
				 int		arrayLen
				)
{
  quickSort_(array,0,arrayLen-1);
}
	  </pre>
	</p>

      </li>
      <p/>

      <li>
	<h4>C programming (20 Points):</h4>
	<p>
	  These two files need a <code>main()</code> to run their functions
	  <code>insertionSort()</code> and <code>quickSort()</code>.
	  Then all three C files need a header file to inform them of what
	  the others have that they need.
	  Please finish both the <code>main()</code> and <code>header.h</code>.
	</p>
	<p>
	  <em>Please note!</em>
	  Not everything needs to be shared.
	  <ul>
	    <li>
	      <code>main()</code> needs
	      <code>insertionSort()</code> and <code>quickSort()</code>
	    </li>
	    <li>
	      Both <code>insertionSort()</code> and <code>quickSort()</code>
	      need <code>swap()</code> and <code>strLen</code>.
	    </li>
	  </ul>
	  Otherwise, it is best <em>not</em> to share too much,
	  kind of like keeping methods and members <code>private</code> in
	  C++ and Java.
	</p>
	<h5>header.h</h5>
	<p>
	  <pre>
/*-------------------------------------------------------------------------*
 *---									---*
 *---		header.h						---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a					Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	&lt;stdlib.h&gt;
#include	&lt;stdio.h&gt;
#include	&lt;string.h&gt;

<strong>// YOUR CODE HERE
extern	int	strLen;

extern	void	swap		(char**		array,
				 int		index0,
				 int		index1
				);

void		insertionSort	(char**		array,
				 int		arrayLen
				);

void		quickSort	(char**		array,
				 int		arrayLen
				);
</strong>
	  </pre>
	</p>
	<h5>main.c</h5>
	<p>
	  <pre>
/*-------------------------------------------------------------------------*
 *---									---*
 *---		main.c							---*
 *---									---*
 *---	    This file defines the variable strLen and function swap()	---*
 *---	needed for the program of assignment 1.				---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a					Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

#include	&quot;header.h&quot;

#define		TEXT_LEN	256


//  PURPOSE:  To tell the length of the strings to sort.
int		strLen;


//  PURPOSE:  To swap the strings in &apos;array[]&apos; at indices &apos;index0&apos; and &apos;index1&apos;.
//	No return value.
void		swap		(char**		array,
				 int		index0,
				 int		index1
				)
{
<strong>  // YOUR CODE HERE
  char*	cPtr	= array[index0];

  array[index0]	= array[index1];
  array[index1]	= cPtr;
</strong>
}


//  PURPOSE:  To repeatedly ask the user the text &quot;Please enter &quot;, followed
//	by the text in &apos;descriptionCPtr&apos;, followed by the numbers &apos;min&apos; and
//	&apos;max&apos;, and to get an entered integer from the user.  If this entered
//	integer is either less than &apos;min&apos;, or is greater than &apos;max&apos;, then
//	the user is asked for another number.  After the user finally enters
//	a legal number, this function returns that number.
int		obtainIntInRange(const char*	descriptionCPtr,
				 int   		min,
				 int		max
				)
{
  int		entry;
  char		text[TEXT_LEN];

<strong>  // YOUR CODE HERE
  do
  {
    printf(&quot;Please enter %s (%d-%d): &quot;,descriptionCPtr, min,max);
    fgets(text,TEXT_LEN,stdin);
    entry	= strtol(text,NULL,0);
  }
  while  ( (entry &lt; min) || (entry &gt; max) );
</strong>

  return(entry);
}


//  PURPOSE:  To generate the array of strings.
char**		generateStringArray
				(int	numStrings
				)
{
  char**	array = (char**)calloc(numStrings,sizeof(char*));
  int		i;
  int		j;

  for  (i = 0;  i &lt; numStrings;  i++)
  {
    array[i]	= (char*)malloc(strLen);

    for  (j = 0;  j &lt; strLen;  j++)
    {
      array[i][j] = (rand() % 16) + &apos;A&apos;;
    }

  }

  return(array);
}


void		print		(char**		array,
				 int		arrayLen
				)
{
  int	i;
  int	j;

  for  (i = 0;  i &lt; arrayLen;  i++)
  {
    for  (j = 0;  j &lt; strLen;  j++)
    {
      putchar(array[i][j]);
    }

    putchar(&apos;\n&apos;);
  }

}


void		releaseMem	(char**		array,
				 int		arrayLen
				)
{
  int	i;

  for  (i = 0;  i &lt; arrayLen;  i++)
  {
    free(array[i]);
  }

  free(array);
}


int		main		()
{
  int		arrayLen;
  char**	array;
  int		choice;

  arrayLen = obtainIntInRange(&quot;number of strings&quot;,1,65536*16);
  strLen   = obtainIntInRange(&quot;length of each string&quot;,1,16);
  choice   = obtainIntInRange(&quot;1 for insertion sort or 2 for quicksort&quot;,1,2);
  array	   = generateStringArray(arrayLen);

  switch  (choice)
  {
  case 1 :
    insertionSort(array,arrayLen);
    break;

  case 2 :
    quickSort(array,arrayLen);
    break;
  }

  print(array,arrayLen);
  releaseMem(array,arrayLen);
  return(EXIT_SUCCESS);
}
	  </pre>
	</p>

	<p>
	  <h4>Sample Initial Output:</h4>
	  <pre>
$ <strong>./assign1 </strong>
Please enter number of strings (1-1048576): <strong>0</strong>
Please enter number of strings (1-1048576): <strong>200000000</strong>
Please enter number of strings (1-1048576): <strong>32</strong>
Please enter length of each string (1-16): <strong>3</strong>
Please enter 1 for insertion sort or 2 for quicksort (1-2): <strong>1</strong>
BID
BMH
BNM
CEB
CLD
CNH
DBP
DDP
EBO
EIL
FHI
GKO
GLE
GMC
HAJ
HGJ
HKM
IHN
ILM
IMK
JKG
JOE
KFN
KMJ
LCN
LCP
LGP
MAL
MEM
NKL
OBB
OBO	  </pre>
	</p>
	
      <li>
	<h4>Timing: Part 1 (20 Points):</h4>
	Compile and run the program without any extra optimizations,
	but with <em>profiling</em> for timing:
	<pre>
gcc -c -pg -O0 main.c
gcc -c -pg -O0 insertionSort.c
gcc -c -pg -O0 quickSort.c
gcc main.o insertionSort.o quickSort.o -pg -O0 -o assign1-0</pre>
	<em>Run the program twice</em>
	timing it both times, and answer the following:

	<ol type="a">
	  <li>
	    <em>
	      How for 65536 strings of length 8 how many <strong>cumulative seconds</strong>
	      did <code>insertionSort()</code> take?
	    </em>
	    <strong>9.73 seconds</strong>
	  </li>
	  <p/>
	  <li>
	    <em>
	      How for 65536 strings of length 8 how many <strong>cumulative seconds</strong>
	      did <code>quickSort_()</code> take?
	    </em>
	    <strong>0.01 seconds</strong>
	  </li>
	</ol>

      </li>
      <p/>

      <li>
	<h4>Timing: Part 2 (20 Points):</h4>
	Compile and run the program <em>with</em> optimization,
	but with <em>profiling</em> for timing:

	<pre>
gcc -c -pg -O2 main.c
gcc -c -pg -O2 insertionSort.c
gcc -c -pg -O2 quickSort.c
gcc main.o insertionSort.o quickSort.o -pg -O2 -o assign1-2</pre>
	<em>Run the program twice</em>
	timing it both times, and answer the following:

	<ol type="a">
	  <li>
	    <em>
	      How for 65536 strings of length 8 how many <strong>cumulative seconds</strong>
	      did <code>insertionSort()</code> take?
	    </em>
	    <strong>5.54 seconds</strong>
	  </li>
	  <p/>
	  <li>
	    <em>
	      How for 65536 strings of length 8 how many <strong>cumulative seconds</strong>
	      did <code>quickSort_()</code> take?
	    </em>
	    <strong>0.01 seconds</strong>
	  </li>
	</ol>

      </li>
      <p/>

      <li>
	<h4>Algorithm choice vs. Compiler optimization (Points 10):</h4>
	<p>
	  Which is faster?
	  <ul>
	    <li>A bad algorithm and data-structure optimized with -O2</li>
	    <li>A good algorithm and data-structure optimized with -O0</li>
	  </ul>
	  <strong>
	    The good algorithm and data-structure optimized with -O0.
	    The compiler will <em>not</em> save your ass!
	    So do not be lazy: choose the best algorithm and data-structure.
	  </strong>
	</p>
      </li>
      <p/>

      <li>
	<h4>Parts of an executable (Points 20):</h4>
	Please find the following inside of <code>assign1-0</code>
	by using <code>objdump</code>.
	<ul>
	  <li>
	    If it <em>can</em> be found then <em>both</em>
	    <ol type="a">
	      <li>Give the <code>objdump</code> command, and</li>
	      <li>Show the <code>objdump</code> result</li>
	    </ol>
	  </li>
	  <p/>

	  <li>
	    If it <em>cannot</em> be found then tell why not.
	    Where in the memory of the runtime process is it?
	  </li>
	</ul>
	<p/>

	Look for:
	<ol type="a">
	  <li>The string <code>&quot;number of strings&quot;</code> in <code>main()</code></li>
	  <li>The code for <code>releaseMem()</code></li>
	  <li>The global variable <code>strLen</code></li>
	  <li>The local variable <code>choice</code> in <code>main()</code></li>
	</ol>
	<table border="1">
	  <tr><th>Question</th> <th align="center">Command</th> <th align="center">Result</th></tr>
	  <tr>
	    <td>(A)</td>
	    <td valign="bottom">$ objdump -s -j .rodata assign1-0</td>
	    <td valign="bottom">
	      <pre>
assign1-0:     file format elf64-x86-64

Contents of section .rodata:
 401078 01000200 00000000 00000000 00000000  ................
 401088 506c6561 73652065 6e746572 20257320  Please enter %s 
 401098 2825642d 2564293a 20006e75 6d626572  (%d-%d): .number
 4010a8 206f6620 73747269 6e677300 6c656e67   of strings.leng
 4010b8 7468206f 66206561 63682073 7472696e  th of each strin
 4010c8 67000000 00000000 3120666f 7220696e  g.......1 for in
 4010d8 73657274 696f6e20 736f7274 206f7220  sertion sort or 
 4010e8 3220666f 72207175 69636b73 6f727400  2 for quicksort.
</pre>
	    </td>
	  </tr>
	  <tr>
	    <td>(B)</td>
	    <td valign="bottom">$ objdump -d -j .text assign1-0</td>
	    <td valign="bottom">
	      <pre>
0000000000400b0d &lt;releaseMem&gt;:
  400b0d:	55                   	push   %rbp
  400b0e:	48 89 e5             	mov    %rsp,%rbp
  400b11:	48 83 ec 20          	sub    $0x20,%rsp
  400b15:	e8 46 fc ff ff       	callq  400760 &lt;mcount@plt&gt;
  400b1a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  400b1e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  400b21:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400b28:	eb 23                	jmp    400b4d &lt;releaseMem+0x40&gt;
  400b2a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400b2d:	48 98                	cltq   
  400b2f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400b36:	00 
  400b37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400b3b:	48 01 d0             	add    %rdx,%rax
  400b3e:	48 8b 00             	mov    (%rax),%rax
  400b41:	48 89 c7             	mov    %rax,%rdi
  400b44:	e8 67 fb ff ff       	callq  4006b0 &lt;free@plt&gt;
  400b49:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400b4d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400b50:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  400b53:	7c d5                	jl     400b2a &lt;releaseMem+0x1d&gt;
  400b55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400b59:	48 89 c7             	mov    %rax,%rdi
  400b5c:	e8 4f fb ff ff       	callq  4006b0 &lt;free@plt&gt;
  400b61:	c9                   	leaveq 
  400b62:	c3                   	retq   
</pre>
	    </td>
	  </tr>
	  <tr>
	    <td>(C)</td>
	    <td valign="bottom">$ objdump -t -j .bss assign1-0</td>
	    <td valign="bottom">
	      <pre>
assign1-0:     file format elf64-x86-64

SYMBOL TABLE:
0000000000602090 l    d  .bss	0000000000000000              .bss
00000000006020a0 l     O .bss	0000000000000004              called.4239
00000000006020a4 l     O .bss	0000000000000001              completed.6355
0000000000602090 g     O .bss	0000000000000008              stdin@@GLIBC_2.2.5
00000000006020a8 g     O .bss	0000000000000004              strLen
00000000006020b0 g       .bss	0000000000000000              _end
000000000060208c g       .bss	0000000000000000              __bss_start
</pre>
	    </td>
	  </tr>
	  <tr>
	    <td>(D)</td>
	    <td colspan="2">
	      <strong>
		It is a local variable, and thus is on the stack.
		Programs do not have stacks (only processes do).
		Therefore, it cannot be found because it does not exist.
	      </strong>
	    </td>
	  </tr>
	</table>
      </li>
      <p/>

      <li>
	<h4>Compiler optimizations (Points 10):</h4>
	Compare the assembly code of <code>assign1-0</code> with
	<code>assign1-2</code>.
	<em>Find</em> and <em>show</em> at least <strong>2</strong> optimizations that the compiler did to make <code>assign1-2</code> run faster than <code>assign1-0</code>.
	<strong>
	  <ol type="a">
	    <li>
	      -O0 the code uses the stack a lot.  Looking at the swap() function we see many uses of rbp:
<pre>
00000000004008bd &lt;swap&gt;:
  4008bd:	55                   	push   %rbp
  4008be:	48 89 e5             	mov    %rsp,%rbp
  4008c1:	48 83 ec 20          	sub    $0x20,%rsp
  4008c5:	e8 96 fe ff ff       	callq  400760 &lt;mcount@plt&gt;
  4008ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4008ce:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  4008d1:	89 55 e0             	mov    %edx,-0x20(%rbp)
  4008d4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
</pre>
	      With -O2 the code keeps values in registers more.  Again looking at swap():
<pre>
00000000004009b0 &lt;swap&gt;:
  4009b0:	55                   	push   %rbp
  4009b1:	48 89 e5             	mov    %rsp,%rbp
  4009b4:	e8 e7 fd ff ff       	callq  4007a0 &lt;mcount@plt&gt;
  4009b9:	48 63 f6             	movslq %esi,%rsi
  4009bc:	48 63 d2             	movslq %edx,%rdx
  4009bf:	48 8d 0c f7          	lea    (%rdi,%rsi,8),%rcx
  4009c3:	48 8d 04 d7          	lea    (%rdi,%rdx,8),%rax
  4009c7:	48 8b 31             	mov    (%rcx),%rsi
</pre>
	    </li>
	    <p/>

	    <li>
	      ith -O0 the print() function uses &quot;movl   $0x0,-0x4(%rbp)&quot; to assign a variable to 0.
	      With -O2 the print() function uses &quot;xor    %ebx,%ebx&quot; to set a value to 0.
	    </li>
	  </ol>
	</strong>
      </li>

    </ol>
  </body>
</html>
